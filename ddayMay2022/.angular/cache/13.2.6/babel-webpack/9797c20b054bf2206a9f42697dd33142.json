{"ast":null,"code":"import _asyncToGenerator from \"/Users/clew/Desktop/newDDayApps/ddayMay2022/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { readBlobAsBase64 } from './utils';\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\n\nconst normalizeHttpHeaders = (headers = {}) => {\n  const originalKeys = Object.keys(headers);\n  const loweredKeys = Object.keys(headers).map(k => k.toLocaleLowerCase());\n  const normalized = loweredKeys.reduce((acc, key, index) => {\n    acc[key] = headers[originalKeys[index]];\n    return acc;\n  }, {});\n  return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\n\n\nconst buildUrlParams = (params, shouldEncode = true) => {\n  if (!params) return null;\n  const output = Object.entries(params).reduce((accumulator, entry) => {\n    const [key, value] = entry;\n    let encodedValue;\n    let item;\n\n    if (Array.isArray(value)) {\n      item = '';\n      value.forEach(str => {\n        encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n        item += `${key}=${encodedValue}&`;\n      }); // last character will always be \"&\" so slice it off\n\n      item.slice(0, -1);\n    } else {\n      encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n      item = `${key}=${encodedValue}`;\n    }\n\n    return `${accumulator}&${item}`;\n  }, ''); // Remove initial \"&\" from the reduce\n\n  return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\n\n\nexport const buildRequestInit = (options, extra = {}) => {\n  const output = Object.assign({\n    method: options.method || 'GET',\n    headers: options.headers\n  }, extra); // Get the content-type\n\n  const headers = normalizeHttpHeaders(options.headers);\n  const type = headers['content-type'] || ''; // If body is already a string, then pass it through as-is.\n\n  if (typeof options.data === 'string') {\n    output.body = options.data;\n  } // Build request initializers based off of content-type\n  else if (type.includes('application/x-www-form-urlencoded')) {\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(options.data || {})) {\n      params.set(key, value);\n    }\n\n    output.body = params.toString();\n  } else if (type.includes('multipart/form-data')) {\n    const form = new FormData();\n\n    if (options.data instanceof FormData) {\n      options.data.forEach((value, key) => {\n        form.append(key, value);\n      });\n    } else {\n      for (let key of Object.keys(options.data)) {\n        form.append(key, options.data[key]);\n      }\n    }\n\n    output.body = form;\n    const headers = new Headers(output.headers);\n    headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n\n    output.headers = headers;\n  } else if (type.includes('application/json') || typeof options.data === 'object') {\n    output.body = JSON.stringify(options.data);\n  }\n\n  return output;\n};\n/**\n * Perform an Http request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const request = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (options) {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n    const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n    const response = yield fetch(url, requestInit);\n    const contentType = response.headers.get('content-type') || ''; // Default to 'text' responseType so no parsing happens\n\n    let {\n      responseType = 'text'\n    } = response.ok ? options : {}; // If the response content-type is json, force the response to be json\n\n    if (contentType.includes('application/json')) {\n      responseType = 'json';\n    }\n\n    let data;\n\n    switch (responseType) {\n      case 'arraybuffer':\n      case 'blob':\n        const blob = yield response.blob();\n        data = yield readBlobAsBase64(blob);\n        break;\n\n      case 'json':\n        data = yield response.json();\n        break;\n\n      case 'document':\n      case 'text':\n      default:\n        data = yield response.text();\n    } // Convert fetch headers to Capacitor HttpHeaders\n\n\n    const headers = {};\n    response.headers.forEach((value, key) => {\n      headers[key] = value;\n    });\n    return {\n      data,\n      headers,\n      status: response.status,\n      url: response.url\n    };\n  });\n\n  return function request(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http GET request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const get = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'GET'\n    }));\n  });\n\n  return function get(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http POST request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const post = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'POST'\n    }));\n  });\n\n  return function post(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http PUT request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const put = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'PUT'\n    }));\n  });\n\n  return function put(_x4) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http PATCH request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const patch = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'PATCH'\n    }));\n  });\n\n  return function patch(_x5) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n/**\n * Perform an Http DELETE request given a set of options\n * @param options Options to build the HTTP request\n */\n\nexport const del = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator(function* (options) {\n    return request(Object.assign(Object.assign({}, options), {\n      method: 'DELETE'\n    }));\n  });\n\n  return function del(_x6) {\n    return _ref6.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/clew/Desktop/newDDayApps/ddayMay2022/node_modules/@capacitor-community/http/dist/esm/request.js"],"names":["readBlobAsBase64","normalizeHttpHeaders","headers","originalKeys","Object","keys","loweredKeys","map","k","toLocaleLowerCase","normalized","reduce","acc","key","index","buildUrlParams","params","shouldEncode","output","entries","accumulator","entry","value","encodedValue","item","Array","isArray","forEach","str","encodeURIComponent","slice","substr","buildRequestInit","options","extra","assign","method","type","data","body","includes","URLSearchParams","set","toString","form","FormData","append","Headers","delete","JSON","stringify","request","requestInit","webFetchExtra","urlParams","shouldEncodeUrlParams","url","response","fetch","contentType","get","responseType","ok","blob","json","text","status","post","put","patch","del"],"mappings":";AAAA,SAASA,gBAAT,QAAiC,SAAjC;AACA;AACA;AACA;AACA;;AACA,MAAMC,oBAAoB,GAAG,CAACC,OAAO,GAAG,EAAX,KAAkB;AAC3C,QAAMC,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAYH,OAAZ,CAArB;AACA,QAAMI,WAAW,GAAGF,MAAM,CAACC,IAAP,CAAYH,OAAZ,EAAqBK,GAArB,CAAyBC,CAAC,IAAIA,CAAC,CAACC,iBAAF,EAA9B,CAApB;AACA,QAAMC,UAAU,GAAGJ,WAAW,CAACK,MAAZ,CAAmB,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,KAAqB;AACvDF,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWX,OAAO,CAACC,YAAY,CAACW,KAAD,CAAb,CAAlB;AACA,WAAOF,GAAP;AACH,GAHkB,EAGhB,EAHgB,CAAnB;AAIA,SAAOF,UAAP;AACH,CARD;AASA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,cAAc,GAAG,CAACC,MAAD,EAASC,YAAY,GAAG,IAAxB,KAAiC;AACpD,MAAI,CAACD,MAAL,EACI,OAAO,IAAP;AACJ,QAAME,MAAM,GAAGd,MAAM,CAACe,OAAP,CAAeH,MAAf,EAAuBL,MAAvB,CAA8B,CAACS,WAAD,EAAcC,KAAd,KAAwB;AACjE,UAAM,CAACR,GAAD,EAAMS,KAAN,IAAeD,KAArB;AACA,QAAIE,YAAJ;AACA,QAAIC,IAAJ;;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcJ,KAAd,CAAJ,EAA0B;AACtBE,MAAAA,IAAI,GAAG,EAAP;AACAF,MAAAA,KAAK,CAACK,OAAN,CAAcC,GAAG,IAAI;AACjBL,QAAAA,YAAY,GAAGN,YAAY,GAAGY,kBAAkB,CAACD,GAAD,CAArB,GAA6BA,GAAxD;AACAJ,QAAAA,IAAI,IAAK,GAAEX,GAAI,IAAGU,YAAa,GAA/B;AACH,OAHD,EAFsB,CAMtB;;AACAC,MAAAA,IAAI,CAACM,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf;AACH,KARD,MASK;AACDP,MAAAA,YAAY,GAAGN,YAAY,GAAGY,kBAAkB,CAACP,KAAD,CAArB,GAA+BA,KAA1D;AACAE,MAAAA,IAAI,GAAI,GAAEX,GAAI,IAAGU,YAAa,EAA9B;AACH;;AACD,WAAQ,GAAEH,WAAY,IAAGI,IAAK,EAA9B;AACH,GAlBc,EAkBZ,EAlBY,CAAf,CAHoD,CAsBpD;;AACA,SAAON,MAAM,CAACa,MAAP,CAAc,CAAd,CAAP;AACH,CAxBD;AAyBA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,gBAAgB,GAAG,CAACC,OAAD,EAAUC,KAAK,GAAG,EAAlB,KAAyB;AACrD,QAAMhB,MAAM,GAAGd,MAAM,CAAC+B,MAAP,CAAc;AAAEC,IAAAA,MAAM,EAAEH,OAAO,CAACG,MAAR,IAAkB,KAA5B;AAAmClC,IAAAA,OAAO,EAAE+B,OAAO,CAAC/B;AAApD,GAAd,EAA6EgC,KAA7E,CAAf,CADqD,CAErD;;AACA,QAAMhC,OAAO,GAAGD,oBAAoB,CAACgC,OAAO,CAAC/B,OAAT,CAApC;AACA,QAAMmC,IAAI,GAAGnC,OAAO,CAAC,cAAD,CAAP,IAA2B,EAAxC,CAJqD,CAKrD;;AACA,MAAI,OAAO+B,OAAO,CAACK,IAAf,KAAwB,QAA5B,EAAsC;AAClCpB,IAAAA,MAAM,CAACqB,IAAP,GAAcN,OAAO,CAACK,IAAtB;AACH,GAFD,CAGA;AAHA,OAIK,IAAID,IAAI,CAACG,QAAL,CAAc,mCAAd,CAAJ,EAAwD;AACzD,UAAMxB,MAAM,GAAG,IAAIyB,eAAJ,EAAf;;AACA,SAAK,MAAM,CAAC5B,GAAD,EAAMS,KAAN,CAAX,IAA2BlB,MAAM,CAACe,OAAP,CAAec,OAAO,CAACK,IAAR,IAAgB,EAA/B,CAA3B,EAA+D;AAC3DtB,MAAAA,MAAM,CAAC0B,GAAP,CAAW7B,GAAX,EAAgBS,KAAhB;AACH;;AACDJ,IAAAA,MAAM,CAACqB,IAAP,GAAcvB,MAAM,CAAC2B,QAAP,EAAd;AACH,GANI,MAOA,IAAIN,IAAI,CAACG,QAAL,CAAc,qBAAd,CAAJ,EAA0C;AAC3C,UAAMI,IAAI,GAAG,IAAIC,QAAJ,EAAb;;AACA,QAAIZ,OAAO,CAACK,IAAR,YAAwBO,QAA5B,EAAsC;AAClCZ,MAAAA,OAAO,CAACK,IAAR,CAAaX,OAAb,CAAqB,CAACL,KAAD,EAAQT,GAAR,KAAgB;AACjC+B,QAAAA,IAAI,CAACE,MAAL,CAAYjC,GAAZ,EAAiBS,KAAjB;AACH,OAFD;AAGH,KAJD,MAKK;AACD,WAAK,IAAIT,GAAT,IAAgBT,MAAM,CAACC,IAAP,CAAY4B,OAAO,CAACK,IAApB,CAAhB,EAA2C;AACvCM,QAAAA,IAAI,CAACE,MAAL,CAAYjC,GAAZ,EAAiBoB,OAAO,CAACK,IAAR,CAAazB,GAAb,CAAjB;AACH;AACJ;;AACDK,IAAAA,MAAM,CAACqB,IAAP,GAAcK,IAAd;AACA,UAAM1C,OAAO,GAAG,IAAI6C,OAAJ,CAAY7B,MAAM,CAAChB,OAAnB,CAAhB;AACAA,IAAAA,OAAO,CAAC8C,MAAR,CAAe,cAAf,EAd2C,CAcX;;AAChC9B,IAAAA,MAAM,CAAChB,OAAP,GAAiBA,OAAjB;AACH,GAhBI,MAiBA,IAAImC,IAAI,CAACG,QAAL,CAAc,kBAAd,KACL,OAAOP,OAAO,CAACK,IAAf,KAAwB,QADvB,EACiC;AAClCpB,IAAAA,MAAM,CAACqB,IAAP,GAAcU,IAAI,CAACC,SAAL,CAAejB,OAAO,CAACK,IAAvB,CAAd;AACH;;AACD,SAAOpB,MAAP;AACH,CAvCM;AAwCP;AACA;AACA;AACA;;AACA,OAAO,MAAMiC,OAAO;AAAA,+BAAG,WAAOlB,OAAP,EAAmB;AACtC,UAAMmB,WAAW,GAAGpB,gBAAgB,CAACC,OAAD,EAAUA,OAAO,CAACoB,aAAlB,CAApC;AACA,UAAMC,SAAS,GAAGvC,cAAc,CAACkB,OAAO,CAACjB,MAAT,EAAiBiB,OAAO,CAACsB,qBAAzB,CAAhC;AACA,UAAMC,GAAG,GAAGF,SAAS,GAAI,GAAErB,OAAO,CAACuB,GAAI,IAAGF,SAAU,EAA/B,GAAmCrB,OAAO,CAACuB,GAAhE;AACA,UAAMC,QAAQ,SAASC,KAAK,CAACF,GAAD,EAAMJ,WAAN,CAA5B;AACA,UAAMO,WAAW,GAAGF,QAAQ,CAACvD,OAAT,CAAiB0D,GAAjB,CAAqB,cAArB,KAAwC,EAA5D,CALsC,CAMtC;;AACA,QAAI;AAAEC,MAAAA,YAAY,GAAG;AAAjB,QAA4BJ,QAAQ,CAACK,EAAT,GAAc7B,OAAd,GAAwB,EAAxD,CAPsC,CAQtC;;AACA,QAAI0B,WAAW,CAACnB,QAAZ,CAAqB,kBAArB,CAAJ,EAA8C;AAC1CqB,MAAAA,YAAY,GAAG,MAAf;AACH;;AACD,QAAIvB,IAAJ;;AACA,YAAQuB,YAAR;AACI,WAAK,aAAL;AACA,WAAK,MAAL;AACI,cAAME,IAAI,SAASN,QAAQ,CAACM,IAAT,EAAnB;AACAzB,QAAAA,IAAI,SAAStC,gBAAgB,CAAC+D,IAAD,CAA7B;AACA;;AACJ,WAAK,MAAL;AACIzB,QAAAA,IAAI,SAASmB,QAAQ,CAACO,IAAT,EAAb;AACA;;AACJ,WAAK,UAAL;AACA,WAAK,MAAL;AACA;AACI1B,QAAAA,IAAI,SAASmB,QAAQ,CAACQ,IAAT,EAAb;AAZR,KAbsC,CA2BtC;;;AACA,UAAM/D,OAAO,GAAG,EAAhB;AACAuD,IAAAA,QAAQ,CAACvD,OAAT,CAAiByB,OAAjB,CAAyB,CAACL,KAAD,EAAQT,GAAR,KAAgB;AACrCX,MAAAA,OAAO,CAACW,GAAD,CAAP,GAAeS,KAAf;AACH,KAFD;AAGA,WAAO;AACHgB,MAAAA,IADG;AAEHpC,MAAAA,OAFG;AAGHgE,MAAAA,MAAM,EAAET,QAAQ,CAACS,MAHd;AAIHV,MAAAA,GAAG,EAAEC,QAAQ,CAACD;AAJX,KAAP;AAMH,GAtCmB;;AAAA,kBAAPL,OAAO;AAAA;AAAA;AAAA,GAAb;AAuCP;AACA;AACA;AACA;;AACA,OAAO,MAAMS,GAAG;AAAA,gCAAG,WAAO3B,OAAP;AAAA,WAAmBkB,OAAO,CAAC/C,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBF,OAAlB,CAAd,EAA0C;AAAEG,MAAAA,MAAM,EAAE;AAAV,KAA1C,CAAD,CAA1B;AAAA,GAAH;;AAAA,kBAAHwB,GAAG;AAAA;AAAA;AAAA,GAAT;AACP;AACA;AACA;AACA;;AACA,OAAO,MAAMO,IAAI;AAAA,gCAAG,WAAOlC,OAAP;AAAA,WAAmBkB,OAAO,CAAC/C,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBF,OAAlB,CAAd,EAA0C;AAAEG,MAAAA,MAAM,EAAE;AAAV,KAA1C,CAAD,CAA1B;AAAA,GAAH;;AAAA,kBAAJ+B,IAAI;AAAA;AAAA;AAAA,GAAV;AACP;AACA;AACA;AACA;;AACA,OAAO,MAAMC,GAAG;AAAA,gCAAG,WAAOnC,OAAP;AAAA,WAAmBkB,OAAO,CAAC/C,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBF,OAAlB,CAAd,EAA0C;AAAEG,MAAAA,MAAM,EAAE;AAAV,KAA1C,CAAD,CAA1B;AAAA,GAAH;;AAAA,kBAAHgC,GAAG;AAAA;AAAA;AAAA,GAAT;AACP;AACA;AACA;AACA;;AACA,OAAO,MAAMC,KAAK;AAAA,gCAAG,WAAOpC,OAAP;AAAA,WAAmBkB,OAAO,CAAC/C,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBF,OAAlB,CAAd,EAA0C;AAAEG,MAAAA,MAAM,EAAE;AAAV,KAA1C,CAAD,CAA1B;AAAA,GAAH;;AAAA,kBAALiC,KAAK;AAAA;AAAA;AAAA,GAAX;AACP;AACA;AACA;AACA;;AACA,OAAO,MAAMC,GAAG;AAAA,gCAAG,WAAOrC,OAAP;AAAA,WAAmBkB,OAAO,CAAC/C,MAAM,CAAC+B,MAAP,CAAc/B,MAAM,CAAC+B,MAAP,CAAc,EAAd,EAAkBF,OAAlB,CAAd,EAA0C;AAAEG,MAAAA,MAAM,EAAE;AAAV,KAA1C,CAAD,CAA1B;AAAA,GAAH;;AAAA,kBAAHkC,GAAG;AAAA;AAAA;AAAA,GAAT","sourcesContent":["import { readBlobAsBase64 } from './utils';\n/**\n * Normalize an HttpHeaders map by lowercasing all of the values\n * @param headers The HttpHeaders object to normalize\n */\nconst normalizeHttpHeaders = (headers = {}) => {\n    const originalKeys = Object.keys(headers);\n    const loweredKeys = Object.keys(headers).map(k => k.toLocaleLowerCase());\n    const normalized = loweredKeys.reduce((acc, key, index) => {\n        acc[key] = headers[originalKeys[index]];\n        return acc;\n    }, {});\n    return normalized;\n};\n/**\n * Builds a string of url parameters that\n * @param params A map of url parameters\n * @param shouldEncode true if you should encodeURIComponent() the values (true by default)\n */\nconst buildUrlParams = (params, shouldEncode = true) => {\n    if (!params)\n        return null;\n    const output = Object.entries(params).reduce((accumulator, entry) => {\n        const [key, value] = entry;\n        let encodedValue;\n        let item;\n        if (Array.isArray(value)) {\n            item = '';\n            value.forEach(str => {\n                encodedValue = shouldEncode ? encodeURIComponent(str) : str;\n                item += `${key}=${encodedValue}&`;\n            });\n            // last character will always be \"&\" so slice it off\n            item.slice(0, -1);\n        }\n        else {\n            encodedValue = shouldEncode ? encodeURIComponent(value) : value;\n            item = `${key}=${encodedValue}`;\n        }\n        return `${accumulator}&${item}`;\n    }, '');\n    // Remove initial \"&\" from the reduce\n    return output.substr(1);\n};\n/**\n * Build the RequestInit object based on the options passed into the initial request\n * @param options The Http plugin options\n * @param extra Any extra RequestInit values\n */\nexport const buildRequestInit = (options, extra = {}) => {\n    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);\n    // Get the content-type\n    const headers = normalizeHttpHeaders(options.headers);\n    const type = headers['content-type'] || '';\n    // If body is already a string, then pass it through as-is.\n    if (typeof options.data === 'string') {\n        output.body = options.data;\n    }\n    // Build request initializers based off of content-type\n    else if (type.includes('application/x-www-form-urlencoded')) {\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(options.data || {})) {\n            params.set(key, value);\n        }\n        output.body = params.toString();\n    }\n    else if (type.includes('multipart/form-data')) {\n        const form = new FormData();\n        if (options.data instanceof FormData) {\n            options.data.forEach((value, key) => {\n                form.append(key, value);\n            });\n        }\n        else {\n            for (let key of Object.keys(options.data)) {\n                form.append(key, options.data[key]);\n            }\n        }\n        output.body = form;\n        const headers = new Headers(output.headers);\n        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary\n        output.headers = headers;\n    }\n    else if (type.includes('application/json') ||\n        typeof options.data === 'object') {\n        output.body = JSON.stringify(options.data);\n    }\n    return output;\n};\n/**\n * Perform an Http request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const request = async (options) => {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);\n    const url = urlParams ? `${options.url}?${urlParams}` : options.url;\n    const response = await fetch(url, requestInit);\n    const contentType = response.headers.get('content-type') || '';\n    // Default to 'text' responseType so no parsing happens\n    let { responseType = 'text' } = response.ok ? options : {};\n    // If the response content-type is json, force the response to be json\n    if (contentType.includes('application/json')) {\n        responseType = 'json';\n    }\n    let data;\n    switch (responseType) {\n        case 'arraybuffer':\n        case 'blob':\n            const blob = await response.blob();\n            data = await readBlobAsBase64(blob);\n            break;\n        case 'json':\n            data = await response.json();\n            break;\n        case 'document':\n        case 'text':\n        default:\n            data = await response.text();\n    }\n    // Convert fetch headers to Capacitor HttpHeaders\n    const headers = {};\n    response.headers.forEach((value, key) => {\n        headers[key] = value;\n    });\n    return {\n        data,\n        headers,\n        status: response.status,\n        url: response.url,\n    };\n};\n/**\n * Perform an Http GET request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const get = async (options) => request(Object.assign(Object.assign({}, options), { method: 'GET' }));\n/**\n * Perform an Http POST request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const post = async (options) => request(Object.assign(Object.assign({}, options), { method: 'POST' }));\n/**\n * Perform an Http PUT request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const put = async (options) => request(Object.assign(Object.assign({}, options), { method: 'PUT' }));\n/**\n * Perform an Http PATCH request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const patch = async (options) => request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));\n/**\n * Perform an Http DELETE request given a set of options\n * @param options Options to build the HTTP request\n */\nexport const del = async (options) => request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));\n"]},"metadata":{},"sourceType":"module"}